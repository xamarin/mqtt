<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ByteExtensions_InvalidBitPosition" xml:space="preserve">
    <value>Bit position must be between 0 and 7</value>
  </data>
  <data name="ByteExtensions_InvalidByteIndex" xml:space="preserve">
    <value>Byte index must be from 1 to 8, starting from msb</value>
  </data>
  <data name="ConnectAckFormatter_InvalidAckFlags" xml:space="preserve">
    <value>Bits 7-1 from Acknowledge flags are reserved and must be set to 0</value>
  </data>
  <data name="ConnectAckFormatter_InvalidSessionPresentForErrorReturnCode" xml:space="preserve">
    <value>Session Present flag must be set to 0 for non-zero return codes</value>
  </data>
  <data name="ConnectFormatter_ClientIdMaxLengthExceeded" xml:space="preserve">
    <value>Client Id cannot exceed 23 bytes</value>
  </data>
  <data name="ConnectFormatter_ClientIdRequired" xml:space="preserve">
    <value>Client Id value is cannot be null or empty</value>
  </data>
  <data name="ConnectFormatter_InvalidClientIdFormat" xml:space="preserve">
    <value>{0} is an invalid ClientId. It must contain only numbers and letters</value>
  </data>
  <data name="ConnectFormatter_InvalidPasswordFlag" xml:space="preserve">
    <value>Password Flag must be set to 0 if the User Name Flag is set to 0</value>
  </data>
  <data name="ConnectFormatter_InvalidProtocolName" xml:space="preserve">
    <value>{0} is not a valid protocol name</value>
  </data>
  <data name="ConnectFormatter_InvalidReservedFlag" xml:space="preserve">
    <value>Reserved Flag must be always set to 0</value>
  </data>
  <data name="ConnectFormatter_InvalidWillRetainFlag" xml:space="preserve">
    <value>Will Retain Flag must be set to 0 if the Will Flag is set to 0</value>
  </data>
  <data name="ConnectFormatter_PasswordNotAllowed" xml:space="preserve">
    <value>Password value must be null or empty if User value is null or empty</value>
  </data>
  <data name="ConnectFormatter_UnsupportedLevel" xml:space="preserve">
    <value>Protocol Level {0} is not supported by the server</value>
  </data>
  <data name="ProtocolEncoding_StringMaxLengthExceeded" xml:space="preserve">
    <value>String value cannot exceed 65536 bytes of length</value>
  </data>
  <data name="Formatter_InvalidHeaderFlag" xml:space="preserve">
    <value>Header Flag {0} is invalid for {1} packet. Expected value: {2}</value>
  </data>
  <data name="Formatter_InvalidPacket" xml:space="preserve">
    <value>The packet sent cannot be handled by {0}</value>
  </data>
  <data name="Formatter_InvalidQualityOfService" xml:space="preserve">
    <value>Qos value must be from 0x00 to 0x02</value>
  </data>
  <data name="PacketManager_PacketUnknown" xml:space="preserve">
    <value>The received packet cannot be handled by any of the registered formatters</value>
  </data>
  <data name="ProtocolEncoding_MalformedRemainingLength" xml:space="preserve">
    <value>Malformed Remaining Length</value>
  </data>
  <data name="ProtocolFlowProvider_UnknownPacketType" xml:space="preserve">
    <value>An error occured while trying to get a Flow Type based on Packet Type {0}</value>
  </data>
  <data name="PublishFormatter_InvalidDuplicatedWithQoSZero" xml:space="preserve">
    <value>Duplicated flag must be set to 0 if the QoS is 0</value>
  </data>
  <data name="PublishFormatter_InvalidPacketId" xml:space="preserve">
    <value>Packet Id is not allowed for packets with QoS 0</value>
  </data>
  <data name="PublishFormatter_InvalidTopicName" xml:space="preserve">
    <value>Topic name {0} is invalid. It cannot be null or empty and It must not contain wildcard characters </value>
  </data>
  <data name="PublishFormatter_PacketIdRequired" xml:space="preserve">
    <value>Packet Id value cannot be null or empty for packets with QoS 1 or 2</value>
  </data>
  <data name="SubscribeAckFormatter_InvalidReturnCodes" xml:space="preserve">
    <value>Return codes can only be valid QoS values or a failure code (0x80)</value>
  </data>
  <data name="SubscribeAckFormatter_MissingReturnCodes" xml:space="preserve">
    <value>A subscribe acknowledge packet must contain at least one return code</value>
  </data>
  <data name="SubscribeFormatter_MissingTopicFilterQosPair" xml:space="preserve">
    <value>A subscribe packet must contain at least one Topic Filter / QoS pair</value>
  </data>
  <data name="UnsubscribeFormatter_MissingTopics" xml:space="preserve">
    <value>An unsubscribe packet must contain at least one topic to unsubscribe</value>
  </data>
  <data name="PublishReceiverFlow_PacketIdRequired" xml:space="preserve">
    <value>Packet Id value is required for QoS major than 0</value>
  </data>
  <data name="SubscribeFormatter_InvalidTopicFilter" xml:space="preserve">
    <value>Topic filter {0} is invalid. See protocol specification for more details on Topic Filter rules: http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718106</value>
  </data>
  <data name="ProtocolEncoding_IntegerMaxValueExceeded" xml:space="preserve">
    <value>Integer values are expected to be of two bytes length. The max value supported is 65536</value>
  </data>
  <data name="TopicEvaluator_InvalidTopicFilter" xml:space="preserve">
    <value>The topic filter {0} is invalid according to the protocol rules and configuration</value>
  </data>
  <data name="TopicEvaluator_InvalidTopicName" xml:space="preserve">
    <value>The topic name {0} is invalid according to the protocol rules</value>
  </data>
  <data name="PublishReceiverFlow_PacketIdNotAllowed" xml:space="preserve">
    <value>Packet Id value is not allowed for QoS 0</value>
  </data>
  <data name="ProtocolFlowProvider_InvalidPacketType" xml:space="preserve">
    <value>The packet type {0} cannot be handled by this flow provider</value>
  </data>
  <data name="PublishFlow_AckMonitor_ExceededMaximumAckRetries" xml:space="preserve">
    <value>The QoS publish flow was not completed within the maximum configured message retries of {0}. The connection will be closed</value>
  </data>
  <data name="SessionRepository_ClientSessionNotFound" xml:space="preserve">
    <value>No session has been found for client {0}</value>
  </data>
  <data name="Tracer_PublishFlow_RetryingQoSFlow" xml:space="preserve">
    <value>The ack for message {0} has not been received. Re sending message for client {1}</value>
  </data>
  <data name="Tracer_Disposing" xml:space="preserve">
    <value>Disposing {0}</value>
  </data>
  <data name="TcpChannel_ClientIsNotConnected" xml:space="preserve">
    <value>The underlying TCP client is not connected</value>
  </data>
  <data name="TcpChannel_SocketDisconnected" xml:space="preserve">
    <value>The underlying network stream is not available. The socket could became disconnected</value>
  </data>
  <data name="Tracer_TcpChannel_DisposeError" xml:space="preserve">
    <value>An error occurred while closing underlying channel. Error code: {0}</value>
  </data>
  <data name="Tracer_TcpChannel_NetworkStreamCompleted" xml:space="preserve">
    <value>The TCP Network Stream has completed sending bytes. The observable sequence will be completed and the channel will be disposed</value>
  </data>
  <data name="Tracer_TcpChannel_ReceivedPacket" xml:space="preserve">
    <value>Received packet of {0} bytes</value>
  </data>
  <data name="Tracer_TcpChannel_SendingPacket" xml:space="preserve">
    <value>Sending packet of {0} bytes</value>
  </data>
  <data name="TcpChannelFactory_TcpClient_Failed" xml:space="preserve">
    <value>An error occurred while connecting via TCP to the endpoint address {0} and port {1}, to establish an MQTT connection</value>
  </data>
  <data name="PacketChannelFactory_InnerChannelFactoryNotFound" xml:space="preserve">
    <value>An inner channel factory is required to create a new packet channel</value>
  </data>
</root>